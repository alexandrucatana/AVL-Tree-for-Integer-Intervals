<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Merge Closed Intervals with AVL Tree: AVL Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Merge Closed Intervals with AVL Tree
   </div>
   <div id="projectbrief">C++ Implementation of an AVL Tree having closed intervals as values</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classAVL-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AVL Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> class used for building an <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> (Adelson-Velsky and Landis) Tree. The node values in this particular implementation are closed integer intervals of the form [4, 16], where 4 is the left-bounded value and 16 is right-bounded value. For simplicity, I call these values low and high.  
 <a href="classAVL.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="avl_8h_source.html">avl.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38cb752b9aab7bd33b5d65c6a1130fc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a38cb752b9aab7bd33b5d65c6a1130fc2">AVL</a> ()</td></tr>
<tr class="memdesc:a38cb752b9aab7bd33b5d65c6a1130fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Initializes the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> root.  <a href="#a38cb752b9aab7bd33b5d65c6a1130fc2">More...</a><br /></td></tr>
<tr class="separator:a38cb752b9aab7bd33b5d65c6a1130fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac119f7c61c6d7dd159a71ae08561596b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#ac119f7c61c6d7dd159a71ae08561596b">~AVL</a> ()</td></tr>
<tr class="memdesc:ac119f7c61c6d7dd159a71ae08561596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Deletes root.  <a href="#ac119f7c61c6d7dd159a71ae08561596b">More...</a><br /></td></tr>
<tr class="separator:ac119f7c61c6d7dd159a71ae08561596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049b94be2949d32aaa21fab2889ed331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a049b94be2949d32aaa21fab2889ed331">insertNode</a> (<a class="el" href="structInterval.html">Interval</a> val)</td></tr>
<tr class="memdesc:a049b94be2949d32aaa21fab2889ed331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method which inserts a new closed interval in the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> Tree. The method checks the balance factor of the tree at every insertion calling the corresponding rotation method in case the tree is not ballanced anymore.  <a href="#a049b94be2949d32aaa21fab2889ed331">More...</a><br /></td></tr>
<tr class="separator:a049b94be2949d32aaa21fab2889ed331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4a4b988eb0de6188176e2fa774c61a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a0d4a4b988eb0de6188176e2fa774c61a">inorder</a> (<a class="el" href="classNode.html">Node</a> *)</td></tr>
<tr class="memdesc:a0d4a4b988eb0de6188176e2fa774c61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses Tree in Inorder:  <a href="#a0d4a4b988eb0de6188176e2fa774c61a">More...</a><br /></td></tr>
<tr class="separator:a0d4a4b988eb0de6188176e2fa774c61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d224d8a9f8ae335f8451ef47cbb026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#ae4d224d8a9f8ae335f8451ef47cbb026">getRoot</a> ()</td></tr>
<tr class="memdesc:ae4d224d8a9f8ae335f8451ef47cbb026"><td class="mdescLeft">&#160;</td><td class="mdescRight">getRoot  <a href="#ae4d224d8a9f8ae335f8451ef47cbb026">More...</a><br /></td></tr>
<tr class="separator:ae4d224d8a9f8ae335f8451ef47cbb026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb567bec2599352ad24fa4169ce9deb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#acfb567bec2599352ad24fa4169ce9deb">breadthFirst</a> (<a class="el" href="classNode.html">Node</a> *)</td></tr>
<tr class="memdesc:acfb567bec2599352ad24fa4169ce9deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The search tree is broadened as much as possible on each depth before going to the next depth.  <a href="#acfb567bec2599352ad24fa4169ce9deb">More...</a><br /></td></tr>
<tr class="separator:acfb567bec2599352ad24fa4169ce9deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c830e3a558e3a225e63eeb2b162347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a23c830e3a558e3a225e63eeb2b162347">deleteNode</a> (<a class="el" href="structInterval.html">Interval</a> val)</td></tr>
<tr class="memdesc:a23c830e3a558e3a225e63eeb2b162347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method which deletes an interval from the tree, making sure that the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> is rebalanced.  <a href="#a23c830e3a558e3a225e63eeb2b162347">More...</a><br /></td></tr>
<tr class="separator:a23c830e3a558e3a225e63eeb2b162347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50e6d4679ec3c3132c0716499975b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#ac50e6d4679ec3c3132c0716499975b05">findNode</a> (<a class="el" href="structInterval.html">Interval</a> val)</td></tr>
<tr class="memdesc:ac50e6d4679ec3c3132c0716499975b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> by value, searching in an <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> Tree is the same as that in Binary Search Tree: the key in each node must be greater than or equal to any key stored in the left sub-tree, and less than or equal to any key stored in the right sub-tree.  <a href="#ac50e6d4679ec3c3132c0716499975b05">More...</a><br /></td></tr>
<tr class="separator:ac50e6d4679ec3c3132c0716499975b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e62f7a85a8c491d2297653056a13a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a85e62f7a85a8c491d2297653056a13a4">getSortedListFromAvl</a> (std::vector&lt; <a class="el" href="structInterval.html">Interval</a> &gt; &amp;sortedList)</td></tr>
<tr class="memdesc:a85e62f7a85a8c491d2297653056a13a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a sorted list from the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> tree by traversing the the tree in inorder.  <a href="#a85e62f7a85a8c491d2297653056a13a4">More...</a><br /></td></tr>
<tr class="separator:a85e62f7a85a8c491d2297653056a13a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0d55f54d7ec30b7ab934bb3dcd6fe811"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a0d55f54d7ec30b7ab934bb3dcd6fe811">height</a> (<a class="el" href="classNode.html">Node</a> *)</td></tr>
<tr class="memdesc:a0d55f54d7ec30b7ab934bb3dcd6fe811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the balance factor of each node.  <a href="#a0d55f54d7ec30b7ab934bb3dcd6fe811">More...</a><br /></td></tr>
<tr class="separator:a0d55f54d7ec30b7ab934bb3dcd6fe811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e873467c6ec64f513f3a669603fe0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#ac7e873467c6ec64f513f3a669603fe0c">doRotations</a> (<a class="el" href="classNode.html">Node</a> *&amp;, bool)</td></tr>
<tr class="memdesc:ac7e873467c6ec64f513f3a669603fe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on the ballance factor of each node, the method decides which rotation method should be called if this is the case.  <a href="#ac7e873467c6ec64f513f3a669603fe0c">More...</a><br /></td></tr>
<tr class="separator:ac7e873467c6ec64f513f3a669603fe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84774181213906c6d20a4b3920c656d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#ac84774181213906c6d20a4b3920c656d">leftRotation</a> (<a class="el" href="classNode.html">Node</a> *&amp;)</td></tr>
<tr class="memdesc:ac84774181213906c6d20a4b3920c656d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> N has balance factor +2 and its right node N_Right has a ballance factor +1 which means its right subree is too long. To balance this tree one replaces N with its N_Right and consequently:  <a href="#ac84774181213906c6d20a4b3920c656d">More...</a><br /></td></tr>
<tr class="separator:ac84774181213906c6d20a4b3920c656d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df181e97c4e3c440628c71a202120fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a0df181e97c4e3c440628c71a202120fe">rightRotation</a> (<a class="el" href="classNode.html">Node</a> *&amp;)</td></tr>
<tr class="memdesc:a0df181e97c4e3c440628c71a202120fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> N has balance factor -2 and its left node N_Left has a ballance factor -1 which means its left subree is too long. To balance this tree one replaces N with its N_Left and consequently:  <a href="#a0df181e97c4e3c440628c71a202120fe">More...</a><br /></td></tr>
<tr class="separator:a0df181e97c4e3c440628c71a202120fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab159f385acf40261f2e762028611c25b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#ab159f385acf40261f2e762028611c25b">leftRightRotation</a> (<a class="el" href="classNode.html">Node</a> *&amp;)</td></tr>
<tr class="memdesc:ab159f385acf40261f2e762028611c25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> N has balance factor -2 and its left node N_Left has a ballance factor +1 which means its left subree is too long. To balance this tree one does first a left rotation on N_Left and then a right rotation on N, thus:  <a href="#ab159f385acf40261f2e762028611c25b">More...</a><br /></td></tr>
<tr class="separator:ab159f385acf40261f2e762028611c25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71915ad84cfe920ff2f3785d819f342b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a71915ad84cfe920ff2f3785d819f342b">rightLeftRotation</a> (<a class="el" href="classNode.html">Node</a> *&amp;)</td></tr>
<tr class="memdesc:a71915ad84cfe920ff2f3785d819f342b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> N has balance factor +2 and its right node N_Right has a ballance factor -1 which means its right subree is too long. To balance this tree one does first a right rotation on N_Right and then a left rotation on N, thus: 1.Replace N_Right with its left child, called grandchild.  <a href="#a71915ad84cfe920ff2f3785d819f342b">More...</a><br /></td></tr>
<tr class="separator:a71915ad84cfe920ff2f3785d819f342b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a065bd4cbd3cad7b7305791ab35f5b570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAVL.html#a065bd4cbd3cad7b7305791ab35f5b570">root</a></td></tr>
<tr class="separator:a065bd4cbd3cad7b7305791ab35f5b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> class used for building an <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> (Adelson-Velsky and Landis) Tree. The node values in this particular implementation are closed integer intervals of the form [4, 16], where 4 is the left-bounded value and 16 is right-bounded value. For simplicity, I call these values low and high. </p>
<p>An <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> Tree is a self balancing Binary Search Tree (BST) in which the maximum difference in height of any node's left and right subtrees is 1, this is also called balance factor which can be defined like this: </p><pre class="fragment">     balance factor = height(right) - height(left)
</pre><p>Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and Deletions may require rebalancing by rotations.</p>
<p>The following class implements four types of insertions: left, right, left-right and right-left insertions.</p>
<p>In this particular implementation, new values are added to the tree like in a BST or just merged to other nodes in the following cases:</p>
<ol type="1">
<li>Full inclusion: the interval to be added is already included in other interval, in this case no new node is added.</li>
<li>Partial inclusion: where the high of the other object becomes high of the current one Ex: compare [14,23] (to insert) to [2,19] (existing) which must be merged to [2,23]</li>
<li>Partial inclusion where the low of the other object becomes low of the current one Ex: compare [8,18] (existing) to [6,15] (to insert) to which must be merged to [6,18]</li>
<li>The new interval can include the current interval. Ex: [1,24] (to insert) includes [2, 23], so [2, 23] is replaced by [1,24]</li>
</ol>
<dl class="section author"><dt>Author</dt><dd>Alexandru Catana </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 2011, Updated: February 2019 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a38cb752b9aab7bd33b5d65c6a1130fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cb752b9aab7bd33b5d65c6a1130fc2">&#9670;&nbsp;</a></span>AVL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AVL::AVL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Initializes the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> root. </p>

</div>
</div>
<a id="ac119f7c61c6d7dd159a71ae08561596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac119f7c61c6d7dd159a71ae08561596b">&#9670;&nbsp;</a></span>~AVL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AVL::~AVL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. Deletes root. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acfb567bec2599352ad24fa4169ce9deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb567bec2599352ad24fa4169ce9deb">&#9670;&nbsp;</a></span>breadthFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::breadthFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The search tree is broadened as much as possible on each depth before going to the next depth. </p>

</div>
</div>
<a id="a23c830e3a558e3a225e63eeb2b162347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c830e3a558e3a225e63eeb2b162347">&#9670;&nbsp;</a></span>deleteNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::deleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInterval.html">Interval</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method which deletes an interval from the tree, making sure that the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> is rebalanced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structInterval.html" title="Interval class which holds the information about a closed interval. It checks for the following cases...">Interval</a></td><td>to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7e873467c6ec64f513f3a669603fe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e873467c6ec64f513f3a669603fe0c">&#9670;&nbsp;</a></span>doRotations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::doRotations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on the ballance factor of each node, the method decides which rotation method should be called if this is the case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a></td><td>which acts like a pivot for the rotations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac50e6d4679ec3c3132c0716499975b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50e6d4679ec3c3132c0716499975b05">&#9670;&nbsp;</a></span>findNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a> * AVL::findNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInterval.html">Interval</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> by value, searching in an <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> Tree is the same as that in Binary Search Tree: the key in each node must be greater than or equal to any key stored in the left sub-tree, and less than or equal to any key stored in the right sub-tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a>: the found node. </dd></dl>

</div>
</div>
<a id="ae4d224d8a9f8ae335f8451ef47cbb026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d224d8a9f8ae335f8451ef47cbb026">&#9670;&nbsp;</a></span>getRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>* AVL::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getRoot </p>
<dl class="section return"><dt>Returns</dt><dd>the root of the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> tree. </dd></dl>

</div>
</div>
<a id="a85e62f7a85a8c491d2297653056a13a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e62f7a85a8c491d2297653056a13a4">&#9670;&nbsp;</a></span>getSortedListFromAvl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::getSortedListFromAvl </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structInterval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sortedList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a sorted list from the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> tree by traversing the the tree in inorder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>the resulted sorted list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d55f54d7ec30b7ab934bb3dcd6fe811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d55f54d7ec30b7ab934bb3dcd6fe811">&#9670;&nbsp;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AVL::height </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the balance factor of each node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a></td><td>for which the balance factor is calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value of the balance factor </dd></dl>

</div>
</div>
<a id="a0d4a4b988eb0de6188176e2fa774c61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4a4b988eb0de6188176e2fa774c61a">&#9670;&nbsp;</a></span>inorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::inorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverses Tree in Inorder: </p>
<ol type="1">
<li>Check if the current node is empty or null.</li>
<li>Traverse the left subtree by recursively calling the in-order function.</li>
<li>Display the data part of the root (or current node).</li>
<li>Traverse the right subtree by recursively calling the in-order function.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param1</td><td><a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> from which the search can start from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a049b94be2949d32aaa21fab2889ed331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049b94be2949d32aaa21fab2889ed331">&#9670;&nbsp;</a></span>insertNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::insertNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInterval.html">Interval</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method which inserts a new closed interval in the <a class="el" href="classAVL.html" title="AVL class used for building an AVL (Adelson-Velsky and Landis) Tree. The node values in this particul...">AVL</a> Tree. The method checks the balance factor of the tree at every insertion calling the corresponding rotation method in case the tree is not ballanced anymore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param1</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab159f385acf40261f2e762028611c25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab159f385acf40261f2e762028611c25b">&#9670;&nbsp;</a></span>leftRightRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::leftRightRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> N has balance factor -2 and its left node N_Left has a ballance factor +1 which means its left subree is too long. To balance this tree one does first a left rotation on N_Left and then a right rotation on N, thus: </p>
<ol type="1">
<li>Replace N_Left with its right child, called grandchild.</li>
<li>Replace N with the grandchild</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a></td><td>which acts like a pivot for the rotations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac84774181213906c6d20a4b3920c656d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84774181213906c6d20a4b3920c656d">&#9670;&nbsp;</a></span>leftRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::leftRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> N has balance factor +2 and its right node N_Right has a ballance factor +1 which means its right subree is too long. To balance this tree one replaces N with its N_Right and consequently: </p>
<ol type="1">
<li>N becomes the left child of N_Right</li>
<li>N_Right's left subtree becomes the right subtree of N</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a></td><td>which acts like a pivot for the rotations </td></tr>
    <tr><td class="paramname">Flag</td><td>used to for either left or right subtree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71915ad84cfe920ff2f3785d819f342b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71915ad84cfe920ff2f3785d819f342b">&#9670;&nbsp;</a></span>rightLeftRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::rightLeftRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> N has balance factor +2 and its right node N_Right has a ballance factor -1 which means its right subree is too long. To balance this tree one does first a right rotation on N_Right and then a left rotation on N, thus: 1.Replace N_Right with its left child, called grandchild. </p>
<ol type="1">
<li>Replace N with the grandchild</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a></td><td>which acts like a pivot for the rotations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0df181e97c4e3c440628c71a202120fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df181e97c4e3c440628c71a202120fe">&#9670;&nbsp;</a></span>rightRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AVL::rightRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>someNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a> N has balance factor -2 and its left node N_Left has a ballance factor -1 which means its left subree is too long. To balance this tree one replaces N with its N_Left and consequently: </p>
<ol type="1">
<li>N becomes the right child of N_Left</li>
<li>N_Left's right subtree becomes the left subtree of N</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classNode.html" title="Node class used to hold the information of an AVLTree. This information is the typical information us...">Node</a></td><td>which acts like a pivot for the rotations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a065bd4cbd3cad7b7305791ab35f5b570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065bd4cbd3cad7b7305791ab35f5b570">&#9670;&nbsp;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>* AVL::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/avl/<a class="el" href="avl_8h_source.html">avl.h</a></li>
<li>src/avl/<a class="el" href="avl_8cpp.html">avl.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
